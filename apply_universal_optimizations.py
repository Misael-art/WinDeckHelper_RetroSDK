#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de Aplica√ß√£o das Otimiza√ß√µes Universais

Este script aplica as otimiza√ß√µes de depend√™ncias identificadas pelo
sistema universal a todos os componentes do ambiente de desenvolvimento.

Autor: Environment Dev Team
Vers√£o: 1.0.0
"""

import os
import sys
import json
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

# Adicionar o diret√≥rio core ao path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'core'))

from universal_dependency_optimizer import (
    UniversalDependencyOptimizer,
    ComponentOptimization,
    get_universal_dependency_optimizer
)

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class OptimizationApplicator:
    """Classe para aplicar otimiza√ß√µes de forma segura e controlada"""
    
    def __init__(self, dry_run: bool = True):
        self.optimizer = get_universal_dependency_optimizer()
        self.dry_run = dry_run
        self.backup_created = False
        
    def run_optimization_process(self) -> bool:
        """Executa o processo completo de otimiza√ß√£o"""
        logger.info("üöÄ Iniciando Processo de Otimiza√ß√£o Universal")
        logger.info("="*60)
        
        if self.dry_run:
            logger.info("üîç MODO DE SIMULA√á√ÉO - Nenhuma altera√ß√£o ser√° feita")
        else:
            logger.info("‚ö†Ô∏è  MODO DE APLICA√á√ÉO - Altera√ß√µes ser√£o aplicadas")
        
        logger.info("="*60)
        
        try:
            # Passo 1: An√°lise inicial
            logger.info("\nüìä Passo 1: An√°lise do ambiente atual")
            analysis = self._analyze_current_environment()
            
            # Passo 2: Identificar otimiza√ß√µes
            logger.info("\nüîç Passo 2: Identificando otimiza√ß√µes poss√≠veis")
            optimizations = self.optimizer.optimize_all_components()
            
            if not optimizations:
                logger.info("‚úÖ Sistema j√° est√° otimizado - nenhuma a√ß√£o necess√°ria")
                return True
            
            # Passo 3: An√°lise de impacto
            logger.info("\nüìà Passo 3: An√°lise de impacto das otimiza√ß√µes")
            impact_analysis = self._analyze_optimization_impact(optimizations)
            
            # Passo 4: Confirma√ß√£o (se n√£o for dry run)
            if not self.dry_run:
                logger.info("\n‚ùì Passo 4: Confirma√ß√£o das altera√ß√µes")
                if not self._confirm_optimizations(impact_analysis):
                    logger.info("‚ùå Opera√ß√£o cancelada pelo usu√°rio")
                    return False
            
            # Passo 5: Backup (se n√£o for dry run)
            if not self.dry_run:
                logger.info("\nüíæ Passo 5: Criando backup")
                self._create_comprehensive_backup()
            
            # Passo 6: Aplicar otimiza√ß√µes
            logger.info("\nüîß Passo 6: Aplicando otimiza√ß√µes")
            if self.dry_run:
                self._simulate_optimizations(optimizations)
            else:
                success = self.optimizer.apply_optimizations_to_files(optimizations, backup=False)
                if not success:
                    logger.error("‚ùå Falha na aplica√ß√£o das otimiza√ß√µes")
                    return False
            
            # Passo 7: Relat√≥rio final
            logger.info("\nüìÑ Passo 7: Gerando relat√≥rio final")
            self._generate_final_report(optimizations, analysis, impact_analysis)
            
            logger.info("\nüéâ Processo de otimiza√ß√£o conclu√≠do com sucesso!")
            return True
            
        except Exception as e:
            logger.error(f"üí• Erro durante o processo de otimiza√ß√£o: {e}")
            return False
    
    def _analyze_current_environment(self) -> Dict[str, Any]:
        """Analisa o ambiente atual"""
        files = self.optimizer._discover_component_files()
        total_components = 0
        components_by_category = {}
        
        for file_path in files:
            components = self.optimizer._load_components_from_file(file_path)
            total_components += len(components)
            
            for name, data in components.items():
                category = data.get('category', 'Unknown')
                if category not in components_by_category:
                    components_by_category[category] = 0
                components_by_category[category] += 1
        
        analysis = {
            'total_files': len(files),
            'total_components': total_components,
            'components_by_category': components_by_category,
            'timestamp': datetime.now().isoformat()
        }
        
        logger.info(f"üìÅ Arquivos de configura√ß√£o: {analysis['total_files']}")
        logger.info(f"üì¶ Total de componentes: {analysis['total_components']}")
        logger.info("üìä Componentes por categoria:")
        for category, count in components_by_category.items():
            logger.info(f"  - {category}: {count}")
        
        return analysis
    
    def _analyze_optimization_impact(self, optimizations: Dict[str, ComponentOptimization]) -> Dict[str, Any]:
        """Analisa o impacto das otimiza√ß√µes"""
        total_savings = {
            'size_mb': sum(opt.estimated_savings['size_mb'] for opt in optimizations.values()),
            'time_seconds': sum(opt.estimated_savings['time_seconds'] for opt in optimizations.values()),
            'dependencies_skipped': sum(opt.estimated_savings['dependencies_skipped'] for opt in optimizations.values())
        }
        
        # Categorizar otimiza√ß√µes por tipo
        optimization_types = {
            'editor_optimizations': [],
            'runtime_optimizations': [],
            'tool_optimizations': [],
            'library_optimizations': []
        }
        
        for name, opt in optimizations.items():
            for dep in opt.skipped_dependencies:
                if 'Visual Studio Code' in dep or 'Cursor' in dep or 'IDE' in dep:
                    optimization_types['editor_optimizations'].append((name, dep))
                elif 'Java' in dep or 'Python' in dep or 'Node.js' in dep:
                    optimization_types['runtime_optimizations'].append((name, dep))
                elif 'Git' in dep or 'Make' in dep or '7-Zip' in dep:
                    optimization_types['tool_optimizations'].append((name, dep))
                else:
                    optimization_types['library_optimizations'].append((name, dep))
        
        impact = {
            'total_optimizations': len(optimizations),
            'total_savings': total_savings,
            'optimization_types': optimization_types,
            'high_impact_optimizations': [
                name for name, opt in optimizations.items() 
                if opt.estimated_savings['size_mb'] > 100
            ]
        }
        
        logger.info(f"üéØ Otimiza√ß√µes identificadas: {impact['total_optimizations']}")
        logger.info(f"üíæ Economia total estimada: {total_savings['size_mb']} MB")
        logger.info(f"‚è±Ô∏è  Tempo total economizado: {total_savings['time_seconds']//60} minutos")
        logger.info(f"‚è≠Ô∏è  Depend√™ncias evitadas: {total_savings['dependencies_skipped']}")
        
        if impact['high_impact_optimizations']:
            logger.info("üèÜ Otimiza√ß√µes de alto impacto:")
            for name in impact['high_impact_optimizations']:
                savings = optimizations[name].estimated_savings
                logger.info(f"  - {name}: {savings['size_mb']} MB")
        
        return impact
    
    def _confirm_optimizations(self, impact_analysis: Dict[str, Any]) -> bool:
        """Solicita confirma√ß√£o do usu√°rio para aplicar otimiza√ß√µes"""
        total_savings = impact_analysis['total_savings']
        
        print("\n" + "="*60)
        print("‚ö†Ô∏è  CONFIRMA√á√ÉO DE OTIMIZA√á√ïES")
        print("="*60)
        print(f"üìä Otimiza√ß√µes a serem aplicadas: {impact_analysis['total_optimizations']}")
        print(f"üíæ Economia estimada: {total_savings['size_mb']} MB")
        print(f"‚è±Ô∏è  Tempo economizado: {total_savings['time_seconds']//60} minutos")
        print(f"‚è≠Ô∏è  Depend√™ncias evitadas: {total_savings['dependencies_skipped']}")
        
        if impact_analysis['high_impact_optimizations']:
            print("\nüèÜ Otimiza√ß√µes de alto impacto:")
            for name in impact_analysis['high_impact_optimizations']:
                print(f"  - {name}")
        
        print("\n‚ö†Ô∏è  ATEN√á√ÉO: Esta opera√ß√£o modificar√° os arquivos de configura√ß√£o.")
        print("üìã Um backup ser√° criado automaticamente.")
        
        while True:
            response = input("\n‚ùì Deseja continuar? (s/N): ").strip().lower()
            if response in ['s', 'sim', 'y', 'yes']:
                return True
            elif response in ['n', 'n√£o', 'nao', 'no', '']:
                return False
            else:
                print("‚ùå Resposta inv√°lida. Digite 's' para sim ou 'n' para n√£o.")
    
    def _create_comprehensive_backup(self) -> None:
        """Cria backup completo do sistema"""
        import shutil
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_dir = Path(f"backups/universal_optimization_{timestamp}")
        backup_dir.mkdir(parents=True, exist_ok=True)
        
        # Backup dos arquivos de configura√ß√£o
        config_dir = Path("config")
        if config_dir.exists():
            shutil.copytree(config_dir, backup_dir / "config", dirs_exist_ok=True)
        
        # Backup dos scripts principais
        important_files = [
            "core/installer.py",
            "core/retro_devkit_manager.py",
            "core/intelligent_dependency_manager.py",
            "core/universal_dependency_optimizer.py"
        ]
        
        scripts_backup = backup_dir / "scripts"
        scripts_backup.mkdir(exist_ok=True)
        
        for file_path in important_files:
            if Path(file_path).exists():
                shutil.copy2(file_path, scripts_backup / Path(file_path).name)
        
        # Criar arquivo de informa√ß√µes do backup
        backup_info = {
            'timestamp': timestamp,
            'backup_reason': 'Universal dependency optimization',
            'files_backed_up': len(list(backup_dir.rglob('*'))),
            'original_config_path': str(config_dir.absolute())
        }
        
        with open(backup_dir / "backup_info.json", 'w', encoding='utf-8') as f:
            json.dump(backup_info, f, indent=2, ensure_ascii=False)
        
        logger.info(f"üíæ Backup completo criado em: {backup_dir}")
        self.backup_created = True
    
    def _simulate_optimizations(self, optimizations: Dict[str, ComponentOptimization]) -> None:
        """Simula a aplica√ß√£o das otimiza√ß√µes"""
        logger.info("üé≠ SIMULA√á√ÉO - As seguintes altera√ß√µes seriam feitas:")
        
        for name, opt in optimizations.items():
            if opt.skipped_dependencies:
                logger.info(f"\nüìù {name}:")
                logger.info(f"  ‚ûñ Depend√™ncias removidas: {', '.join(opt.skipped_dependencies)}")
                
                if opt.conditional_dependencies:
                    logger.info(f"  üîÄ Depend√™ncias condicionais adicionadas: {len(opt.conditional_dependencies)}")
                
                savings = opt.estimated_savings
                logger.info(f"  üíæ Economia: {savings['size_mb']} MB, {savings['time_seconds']//60} min")
    
    def _generate_final_report(self, optimizations: Dict[str, ComponentOptimization], 
                             analysis: Dict[str, Any], impact_analysis: Dict[str, Any]) -> None:
        """Gera relat√≥rio final completo"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_path = f"optimization_final_report_{timestamp}.json"
        
        # Gerar relat√≥rio do otimizador
        optimization_report = self.optimizer.generate_optimization_report(optimizations)
        
        # Combinar com an√°lises adicionais
        final_report = {
            'process_info': {
                'timestamp': datetime.now().isoformat(),
                'dry_run': self.dry_run,
                'backup_created': self.backup_created
            },
            'environment_analysis': analysis,
            'impact_analysis': impact_analysis,
            'optimization_details': optimization_report,
            'recommendations': self._generate_recommendations(optimizations, impact_analysis)
        }
        
        # Salvar relat√≥rio
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(final_report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"üìÑ Relat√≥rio final salvo: {report_path}")
        
        # Mostrar resumo
        self._show_final_summary(final_report)
    
    def _generate_recommendations(self, optimizations: Dict[str, ComponentOptimization], 
                                impact_analysis: Dict[str, Any]) -> List[str]:
        """Gera recomenda√ß√µes baseadas nas otimiza√ß√µes"""
        recommendations = []
        
        total_savings = impact_analysis['total_savings']
        
        if total_savings['size_mb'] > 500:
            recommendations.append(
                "üíæ Grande economia de espa√ßo identificada. Considere aplicar as otimiza√ß√µes para liberar espa√ßo significativo."
            )
        
        if total_savings['time_seconds'] > 600:  # 10 minutos
            recommendations.append(
                "‚è±Ô∏è  Economia significativa de tempo de instala√ß√£o. As otimiza√ß√µes reduzir√£o substancialmente o tempo de setup."
            )
        
        editor_optimizations = impact_analysis['optimization_types']['editor_optimizations']
        if len(editor_optimizations) > 3:
            recommendations.append(
                "üñ•Ô∏è  M√∫ltiplas otimiza√ß√µes de editores detectadas. O sistema instalar√° apenas editores necess√°rios baseado no ambiente."
            )
        
        if impact_analysis['high_impact_optimizations']:
            recommendations.append(
                f"üéØ {len(impact_analysis['high_impact_optimizations'])} otimiza√ß√µes de alto impacto identificadas. Priorize a aplica√ß√£o destas."
            )
        
        recommendations.append(
            "üîÑ Execute este processo periodicamente para manter o sistema otimizado conforme novos componentes s√£o adicionados."
        )
        
        return recommendations
    
    def _show_final_summary(self, final_report: Dict[str, Any]) -> None:
        """Mostra resumo final"""
        logger.info("\n" + "="*60)
        logger.info("üìä RESUMO FINAL DO PROCESSO")
        logger.info("="*60)
        
        process_info = final_report['process_info']
        impact = final_report['impact_analysis']
        total_savings = impact['total_savings']
        
        logger.info(f"üïê Processo executado em: {process_info['timestamp']}")
        logger.info(f"üé≠ Modo: {'Simula√ß√£o' if process_info['dry_run'] else 'Aplica√ß√£o'}")
        
        if process_info['backup_created']:
            logger.info("üíæ Backup criado com sucesso")
        
        logger.info(f"\nüìà RESULTADOS:")
        logger.info(f"  üéØ Otimiza√ß√µes aplicadas: {impact['total_optimizations']}")
        logger.info(f"  üíæ Espa√ßo economizado: {total_savings['size_mb']} MB")
        logger.info(f"  ‚è±Ô∏è  Tempo economizado: {total_savings['time_seconds']//60} minutos")
        logger.info(f"  ‚è≠Ô∏è  Depend√™ncias evitadas: {total_savings['dependencies_skipped']}")
        
        recommendations = final_report['recommendations']
        if recommendations:
            logger.info("\nüí° RECOMENDA√á√ïES:")
            for i, rec in enumerate(recommendations, 1):
                logger.info(f"  {i}. {rec}")
        
        logger.info("="*60)

def main():
    """Fun√ß√£o principal"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Aplica otimiza√ß√µes universais de depend√™ncias",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemplos de uso:
  python apply_universal_optimizations.py --dry-run    # Simular otimiza√ß√µes
  python apply_universal_optimizations.py --apply     # Aplicar otimiza√ß√µes
        """
    )
    
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--dry-run', action='store_true', 
                      help='Simular otimiza√ß√µes sem aplicar altera√ß√µes')
    group.add_argument('--apply', action='store_true', 
                      help='Aplicar otimiza√ß√µes aos arquivos')
    
    args = parser.parse_args()
    
    print("üîß Sistema de Otimiza√ß√£o Universal de Depend√™ncias")
    print("="*60)
    
    applicator = OptimizationApplicator(dry_run=args.dry_run)
    success = applicator.run_optimization_process()
    
    if success:
        if args.dry_run:
            print("\n‚úÖ Simula√ß√£o conclu√≠da com sucesso!")
            print("üí° Use --apply para aplicar as otimiza√ß√µes")
        else:
            print("\nüéâ Otimiza√ß√µes aplicadas com sucesso!")
    else:
        print("\n‚ùå Processo falhou. Verifique os logs acima.")
    
    return success

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)