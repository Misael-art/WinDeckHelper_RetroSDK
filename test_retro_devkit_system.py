#!/usr/bin/env python3
"""
Teste abrangente do sistema de DevKits Retro
Valida instala√ß√£o, configura√ß√£o e integra√ß√£o completa
"""

import os
import sys
import json
import tempfile
import shutil
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock

# Adicionar o diret√≥rio do projeto ao path
sys.path.insert(0, str(Path(__file__).parent))

from env_dev.core.retro_devkit_manager import RetroDevKitManager, ConsoleGeneration, ConsoleType
from env_dev.core.retro_integration import RetroIntegration
from env_dev.core.configuration_manager_enhanced import EnhancedConfigurationManager as ConfigurationManager
from env_dev.core.installation_manager import InstallationManager

class RetroDevKitTester:
    """Tester completo para o sistema de DevKits Retro"""
    
    def __init__(self):
        self.temp_dir = None
        self.setup_test_environment()
        
    def setup_test_environment(self):
        """Configura ambiente de teste isolado"""
        self.temp_dir = tempfile.mkdtemp(prefix="retro_devkit_test_")
        print(f"üîß Ambiente de teste criado em: {self.temp_dir}")
        
        # Configurar managers com diret√≥rio tempor√°rio
        self.config_manager = ConfigurationManager(base_path=self.temp_dir)
        self.installation_manager = InstallationManager(self.temp_dir)
        self.retro_manager = RetroDevKitManager(base_path=self.temp_dir)
        self.retro_integration = RetroIntegration(self.installation_manager, self.config_manager)
        
    def cleanup(self):
        """Limpa ambiente de teste"""
        if self.temp_dir and Path(self.temp_dir).exists():
            shutil.rmtree(self.temp_dir)
            print(f"üßπ Ambiente de teste limpo: {self.temp_dir}")
    
    def test_devkit_initialization(self):
        """Testa inicializa√ß√£o dos devkits"""
        print("\nüìã Testando inicializa√ß√£o dos DevKits...")
        
        # Verificar se todos os devkits foram carregados
        devkits = self.retro_manager.devkits
        assert len(devkits) > 0, "Nenhum devkit foi carregado"
        
        # Verificar categorias esperadas
        expected_consoles = [
            'nes', 'gameboy', 'snes', 'megadrive', 'playstation1', 
            'gba', 'nds', 'psp', 'saturn', 'nintendo64'
        ]
        
        found_consoles = []
        for console_id in expected_consoles:
            if console_id in devkits:
                found_consoles.append(console_id)
                devkit = devkits[console_id]
                
                # Validar estrutura do devkit
                assert devkit.name, f"DevKit {console_id} sem nome"
                assert devkit.console, f"DevKit {console_id} sem console"
                assert devkit.devkit_name, f"DevKit {console_id} sem nome do devkit"
                assert devkit.dependencies, f"DevKit {console_id} sem depend√™ncias"
                assert devkit.environment_vars, f"DevKit {console_id} sem vari√°veis de ambiente"
                
                print(f"  ‚úÖ {console_id}: {devkit.name}")
        
        print(f"üìä {len(found_consoles)}/{len(expected_consoles)} consoles esperados encontrados")
        return True
    
    def test_devkit_categories(self):
        """Testa categoriza√ß√£o dos devkits"""
        print("\nüè∑Ô∏è Testando categoriza√ß√£o dos DevKits...")
        
        categories = self.retro_manager.list_available_devkits()
        
        expected_categories = [
            "8-bit Home Consoles",
            "8-bit Portable Consoles", 
            "16-bit Home Consoles",
            "16-bit Portable Consoles",
            "32-bit Home Consoles",
            "32-bit Portable Consoles"
        ]
        
        for category in expected_categories:
            assert category in categories, f"Categoria {category} n√£o encontrada"
            devkits_in_category = categories[category]
            
            if devkits_in_category:
                print(f"  ‚úÖ {category}: {len(devkits_in_category)} devkits")
                
                # Verificar estrutura dos devkits na categoria
                for devkit in devkits_in_category:
                    assert 'id' in devkit, "DevKit sem ID"
                    assert 'name' in devkit, "DevKit sem nome"
                    assert 'console' in devkit, "DevKit sem console"
                    assert 'emulators' in devkit, "DevKit sem emuladores"
            else:
                print(f"  ‚ö†Ô∏è {category}: vazia")
        
        return True
    
    def test_environment_variables(self):
        """Testa configura√ß√£o de vari√°veis de ambiente"""
        print("\nüåç Testando vari√°veis de ambiente...")
        
        # Testar alguns devkits espec√≠ficos
        test_devkits = ['gameboy', 'snes', 'psp']
        
        for devkit_id in test_devkits:
            if devkit_id in self.retro_manager.devkits:
                devkit = self.retro_manager.devkits[devkit_id]
                env_vars = devkit.environment_vars
                
                assert env_vars, f"DevKit {devkit_id} sem vari√°veis de ambiente"
                
                # Verificar se as vari√°veis fazem sentido
                for var, value in env_vars.items():
                    assert var, "Vari√°vel de ambiente sem nome"
                    assert value, "Vari√°vel de ambiente sem valor"
                    assert isinstance(value, str), "Valor da vari√°vel deve ser string"
                
                print(f"  ‚úÖ {devkit_id}: {len(env_vars)} vari√°veis configuradas")
        
        return True
    
    def test_integration_registration(self):
        """Testa registro dos devkits no sistema principal"""
        print("\nüîó Testando integra√ß√£o com sistema principal...")
        
        # Registrar devkits
        self.retro_integration.register_retro_apps()
        
        # Verificar se foram registrados
        registered_apps = self.installation_manager.get_registered_applications()
        
        retro_apps = [app for app in registered_apps if 'retro' in app.get('tags', [])]
        assert len(retro_apps) > 0, "Nenhum devkit retro foi registrado"
        
        print(f"  ‚úÖ {len(retro_apps)} devkits registrados no sistema principal")
        
        # Verificar estrutura de um app registrado
        sample_app = retro_apps[0]
        required_fields = ['name', 'description', 'category', 'dependencies', 'environment_vars']
        
        for field in required_fields:
            assert field in sample_app, f"Campo {field} ausente no app registrado"
        
        return True
    
    def test_installation_simulation(self):
        """Simula instala√ß√£o de devkits (sem executar comandos reais)"""
        print("\n‚öôÔ∏è Testando simula√ß√£o de instala√ß√£o...")
        
        # Mock dos comandos do sistema para evitar instala√ß√£o real
        with patch('subprocess.run') as mock_run:
            # Configurar mock para simular sucesso
            mock_run.return_value = Mock(returncode=0, stdout="", stderr="")
            
            # Testar instala√ß√£o de um devkit simples
            test_devkit = 'gameboy'
            
            if test_devkit in self.retro_manager.devkits:
                # Simular instala√ß√£o
                success = self.retro_integration.install_retro_devkit(test_devkit, use_docker=False)
                
                # Verificar se a instala√ß√£o foi "bem-sucedida"
                print(f"  ‚úÖ Simula√ß√£o de instala√ß√£o do {test_devkit}: {'Sucesso' if success else 'Falha'}")
                
                # Verificar se comandos foram chamados
                assert mock_run.called, "Nenhum comando de instala√ß√£o foi executado"
                
        return True
    
    def test_project_template_creation(self):
        """Testa cria√ß√£o de templates de projeto"""
        print("\nüìÅ Testando cria√ß√£o de templates de projeto...")
        
        test_devkit = 'gameboy'
        project_name = "test_retro_project"
        project_path = Path(self.temp_dir) / project_name
        
        # Criar template
        success = self.retro_manager.create_project_template(
            test_devkit, 
            project_name, 
            str(project_path)
        )
        
        assert success, "Falha na cria√ß√£o do template"
        assert project_path.exists(), "Diret√≥rio do projeto n√£o foi criado"
        
        # Verificar estrutura do projeto
        expected_files = ['Makefile', 'README.md']
        expected_dirs = ['src', 'assets', 'build']
        
        for file_name in expected_files:
            file_path = project_path / file_name
            assert file_path.exists(), f"Arquivo {file_name} n√£o foi criado"
            assert file_path.stat().st_size > 0, f"Arquivo {file_name} est√° vazio"
        
        for dir_name in expected_dirs:
            dir_path = project_path / dir_name
            assert dir_path.exists(), f"Diret√≥rio {dir_name} n√£o foi criado"
            assert dir_path.is_dir(), f"{dir_name} n√£o √© um diret√≥rio"
        
        # Verificar conte√∫do do arquivo principal
        main_file = project_path / "src" / "main.c"
        assert main_file.exists(), "Arquivo main.c n√£o foi criado"
        
        with open(main_file, 'r') as f:
            content = f.read()
            assert project_name in content, "Nome do projeto n√£o est√° no c√≥digo"
            assert "Game Boy" in content, "Refer√™ncia ao console n√£o encontrada"
        
        print(f"  ‚úÖ Template criado com sucesso em {project_path}")
        return True
    
    def test_workspace_creation(self):
        """Testa cria√ß√£o de workspace de desenvolvimento"""
        print("\nüèóÔ∏è Testando cria√ß√£o de workspace...")
        
        workspace_name = "test_retro_workspace"
        devkit_ids = ['gameboy', 'snes']
        
        # Criar workspace
        success = self.retro_integration.create_development_workspace(
            workspace_name, 
            devkit_ids
        )
        
        assert success, "Falha na cria√ß√£o do workspace"
        
        # Verificar estrutura do workspace
        workspace_path = Path.home() / "RetroWorkspaces" / workspace_name
        
        if workspace_path.exists():
            expected_dirs = ['projects', 'shared', 'tools', 'emulators']
            expected_files = ['workspace.json', 'activate.bat', 'activate.sh']
            
            for dir_name in expected_dirs:
                dir_path = workspace_path / dir_name
                assert dir_path.exists(), f"Diret√≥rio {dir_name} n√£o foi criado"
            
            for file_name in expected_files:
                file_path = workspace_path / file_name
                assert file_path.exists(), f"Arquivo {file_name} n√£o foi criado"
            
            # Verificar configura√ß√£o do workspace
            config_file = workspace_path / "workspace.json"
            with open(config_file, 'r') as f:
                config = json.load(f)
                assert config['name'] == workspace_name
                assert config['devkits'] == devkit_ids
            
            print(f"  ‚úÖ Workspace criado com sucesso")
            
            # Limpar workspace de teste
            shutil.rmtree(workspace_path)
        
        return True
    
    def test_batch_operations(self):
        """Testa opera√ß√µes em lote"""
        print("\nüì¶ Testando opera√ß√µes em lote...")
        
        # Testar instala√ß√£o por gera√ß√£o (simulada)
        with patch('subprocess.run') as mock_run:
            mock_run.return_value = Mock(returncode=0, stdout="", stderr="")
            
            # Instalar todos os devkits de 8-bit
            results = self.retro_integration.batch_install_by_generation(
                ConsoleGeneration.BIT_8, 
                use_docker=False
            )
            
            assert len(results) > 0, "Nenhum devkit de 8-bit encontrado"
            print(f"  ‚úÖ Instala√ß√£o em lote 8-bit: {len(results)} devkits processados")
            
            # Testar instala√ß√£o por tipo
            results = self.retro_integration.batch_install_by_type(
                ConsoleType.PORTABLE, 
                use_docker=False
            )
            
            assert len(results) > 0, "Nenhum devkit port√°til encontrado"
            print(f"  ‚úÖ Instala√ß√£o em lote port√°teis: {len(results)} devkits processados")
        
        return True
    
    def test_export_functionality(self):
        """Testa funcionalidade de exporta√ß√£o"""
        print("\nüì§ Testando exporta√ß√£o de dados...")
        
        # Testar exporta√ß√£o JSON
        json_data = self.retro_integration.export_devkit_list('json')
        assert json_data, "Exporta√ß√£o JSON falhou"
        
        # Verificar se √© JSON v√°lido
        try:
            parsed_json = json.loads(json_data)
            assert isinstance(parsed_json, list), "JSON exportado n√£o √© uma lista"
            assert len(parsed_json) > 0, "Lista JSON est√° vazia"
            print("  ‚úÖ Exporta√ß√£o JSON v√°lida")
        except json.JSONDecodeError:
            assert False, "JSON exportado √© inv√°lido"
        
        # Testar exporta√ß√£o CSV
        csv_data = self.retro_integration.export_devkit_list('csv')
        assert csv_data, "Exporta√ß√£o CSV falhou"
        assert 'category,id,name' in csv_data, "Cabe√ßalho CSV n√£o encontrado"
        print("  ‚úÖ Exporta√ß√£o CSV v√°lida")
        
        return True
    
    def test_installation_summary(self):
        """Testa gera√ß√£o de resumo de instala√ß√£o"""
        print("\nüìä Testando resumo de instala√ß√£o...")
        
        summary = self.retro_integration.get_retro_installation_summary()
        
        # Verificar estrutura do resumo
        required_fields = ['total_devkits', 'installed_count', 'installation_status', 'categories', 'recommendations']
        
        for field in required_fields:
            assert field in summary, f"Campo {field} ausente no resumo"
        
        assert isinstance(summary['total_devkits'], int), "total_devkits deve ser inteiro"
        assert isinstance(summary['installed_count'], int), "installed_count deve ser inteiro"
        assert isinstance(summary['categories'], dict), "categories deve ser dict"
        assert isinstance(summary['recommendations'], list), "recommendations deve ser lista"
        
        print(f"  ‚úÖ Resumo gerado: {summary['total_devkits']} devkits total")
        
        # Verificar recomenda√ß√µes
        recommendations = summary['recommendations']
        assert len(recommendations) > 0, "Nenhuma recomenda√ß√£o gerada"
        
        for rec in recommendations:
            assert 'title' in rec, "Recomenda√ß√£o sem t√≠tulo"
            assert 'devkits' in rec, "Recomenda√ß√£o sem devkits"
            assert isinstance(rec['devkits'], list), "devkits deve ser lista"
        
        print(f"  ‚úÖ {len(recommendations)} recomenda√ß√µes geradas")
        
        return True
    
    def run_all_tests(self):
        """Executa todos os testes"""
        print("üöÄ Iniciando testes do sistema de DevKits Retro")
        print("=" * 60)
        
        tests = [
            self.test_devkit_initialization,
            self.test_devkit_categories,
            self.test_environment_variables,
            self.test_integration_registration,
            self.test_installation_simulation,
            self.test_project_template_creation,
            self.test_workspace_creation,
            self.test_batch_operations,
            self.test_export_functionality,
            self.test_installation_summary
        ]
        
        passed = 0
        failed = 0
        
        for test in tests:
            try:
                test()
                passed += 1
                print(f"‚úÖ {test.__name__}")
            except Exception as e:
                failed += 1
                print(f"‚ùå {test.__name__}: {e}")
        
        print("\n" + "=" * 60)
        print(f"üìä Resultados dos testes:")
        print(f"  ‚úÖ Passou: {passed}")
        print(f"  ‚ùå Falhou: {failed}")
        print(f"  üìà Taxa de sucesso: {(passed/(passed+failed)*100):.1f}%")
        
        if failed == 0:
            print("\nüéâ Todos os testes passaram! Sistema de DevKits Retro est√° funcionando corretamente.")
        else:
            print(f"\n‚ö†Ô∏è {failed} teste(s) falharam. Verifique os erros acima.")
        
        return failed == 0


def main():
    """Fun√ß√£o principal"""
    tester = RetroDevKitTester()
    
    try:
        success = tester.run_all_tests()
        
        if success:
            print("\nüéØ Demonstra√ß√£o das funcionalidades:")
            
            # Mostrar devkits dispon√≠veis
            print("\nüìã DevKits Dispon√≠veis:")
            categories = tester.retro_manager.list_available_devkits()
            for category, devkits in categories.items():
                if devkits:
                    print(f"\n  {category}:")
                    for devkit in devkits[:3]:  # Mostrar apenas os primeiros 3
                        print(f"    ‚Ä¢ {devkit['name']} ({devkit['id']})")
                        print(f"      Emuladores: {', '.join(devkit['emulators'][:2])}")
            
            # Mostrar resumo
            print("\nüìä Resumo do Sistema:")
            summary = tester.retro_integration.get_retro_installation_summary()
            print(f"  ‚Ä¢ Total de DevKits: {summary['total_devkits']}")
            print(f"  ‚Ä¢ Categorias: {len(summary['categories'])}")
            print(f"  ‚Ä¢ Recomenda√ß√µes: {len(summary['recommendations'])}")
            
            # Mostrar recomenda√ß√µes
            print("\nüí° Recomenda√ß√µes para Iniciantes:")
            for rec in summary['recommendations'][:2]:
                print(f"  ‚Ä¢ {rec['title']}: {rec['description']}")
        
        return 0 if success else 1
        
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Teste interrompido pelo usu√°rio")
        return 1
    except Exception as e:
        print(f"\nüí• Erro inesperado: {e}")
        return 1
    finally:
        tester.cleanup()


if __name__ == "__main__":
    exit(main())